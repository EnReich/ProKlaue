% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}


\title{ProKlaue Documentation}
\date{Sep 13, 2016}
\release{0.3.1}
\author{Enrico Reich}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}

\index{proKlaue (module)}\phantomsection\label{index:module-proKlaue}\index{proKlaue (module)}
\href{http://www.zv.uni-leipzig.de/service/kommunikation/medienredaktion/nachrichten.html?ifab\_modus=detail\&ifab\_id=6004}{ProKlaue} is a biomechanic research project at the Faculty of Veterinary Medicine of the University of Leipzig (Saxony, Germany). The primary goal is to be able to align bone models in a repeatable and deterministic way, as well as to export comparable measures of each bone model over a whole animation for further analysis.

To support the necessary work and to provide some useful routines inside the 3D-modelling and animation program \emph{Maya Autodesk} the plugin \emph{proKlaue} was written, which uses the \href{http://download.autodesk.com/us/maya/2011help/CommandsPython/}{Python-API} of Maya and Python-Libraries for numerical computation (\href{http://www.numpy.org/}{numpy}, \href{https://www.scipy.org/}{scipy}, \href{https://github.com/kmammou/v-hacd}{V-HACD}). The Plugin introduces not only different scripts which are registered as commands inside Maya (for easier usage) but also a number of useful functions for general mesh-based tasks. There are a few additional functions like calculation of the convex hull, delaunay triangulation, intersection volume of multiple mesh objects and a cleanup process where one can extract a specific shell of a mesh (to eliminate possible entrapments inside a bone model caused by e.g. air, vessels or imaging errors).


\chapter{Requirements}
\label{index:welcome-to-proklaue-s-documentation}\label{index:main}\label{index:requirements}\label{index:module-proKlaue}\begin{itemize}
\item {} 
Maya Autodesk 2013 (or newer)

\item {} 
Numpy Package for Python2.7 (at least 0.12.0)

\item {} 
Scipy Package for Python2.7 (at least 0.16.0)

\item {} 
V-HACD Library

\end{itemize}


\section{Installation of Numpy \& Scipy for Maya}
\label{index:installation-of-numpy-scipy-for-maya}
Maya Autodesk is shipped with its own Python2.7-Installation which does not make any use of already existing Python-Installations on the system. This includes all Python-Libraries as well. So in order to make Python-Libraries work directly inside Maya, the following steps are necessary:
\begin{itemize}
\item {} 
Installation of Python 2.7 for the current system

\item {} 
Install \emph{Numpy} and \emph{Scipy} (either using the Linux install repository or the \emph{pip}-command of python, e.g. `pip install -i \url{https://pypi.anaconda.org/carlkl/simple} numpy')

\item {} 
Search subdirectory `site-packages' in Python2.7 install path

\item {} 
Select and copy directories \emph{numpy} \& \emph{scipy}

\item {} 
Go to the Maya Directory (e.g. `C://Program Files/Autodesk/Maya2014/Python/lib/site-packages') and insert copied files

\end{itemize}

After a restart of Maya the command `import numpy' should be usable; if not the wrong version was installed.


\subsection{Troubleshooting}
\label{index:troubleshooting}\begin{itemize}
\item {} 
\textbf{command pip was not found}: navigate to the python-subdirectory \emph{Scripts} (`cd ``C://Program Files/Python27/Scripts/''') and try again. Or insert Path `Python27/Scripts' to PATH-Variable

\item {} 
\textbf{Maya Error: module `numpy' not found}: the `numpy' directory is in the wrong Maya subdirectory. It needs to be inside Maya's Python-Directory `lib/site-packages/'

\item {} 
\textbf{Maya throws dll-Error with reference to Win32}: wrong Python-Version and consequently wrong library versions are installed. Since Maya Autodesk 2014 there is only a 64bit version. This means that Python also needs to be installed as 64bit version. It is also advisable to update `pip' (`python -m pip install -U pip') \textbf{before} installation of the libraries. Further the packages should be installed without any optimizations to avoid conflicts.

\end{itemize}


\chapter{Installation and configuration of the Plugin}
\label{index:installation-and-configuration-of-the-plugin}\begin{itemize}
\item {} 
Copy everything to `Autodesk/maya\textless{}version\textgreater{}/bin/plug-ins' so that the file `proKlaue.py' lies directly inside this directory

\item {} 
Inside Maya: Windows --\textgreater{} Settings/Preferences --\textgreater{} Plugin-in Manager --\textgreater{} Refresh

\item {} 
Search for the entry `proKlaue.py' and check `Loaded' and `Auto load'

\end{itemize}

After the plugin has been successfully loaded a new shelf tab named `ProKlaue' will appear.

At last, activate the following setting: Windows --\textgreater{} Settings/Preferences --\textgreater{} Preferences --\textgreater{} Setting --\textgreater{} Selection --\textgreater{} `Track selection order'

To use the console commands directly inside Maya, one need to execute the Python command `import maya.cmds as cmds' after each program restart (this can be done automatically by creating a file `userSetup.py' inside the directory `/home/user/maya/version/scripts/' and write the line `import maya.cmds as cmds' inside). All commands can then be executed by typing `cmds.\textless{}cmd\textgreater{}' where \emph{cmd} is a placeholder for the command's name.


\chapter{Commands}
\label{index:commands}\label{index:id1}

\section{adjustAxisDirection}
\label{pk_src.adjustAxisDirection::doc}\label{pk_src.adjustAxisDirection:adjustaxisdirection}\label{pk_src.adjustAxisDirection:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.adjustAxisDirection:module-pk_src.adjustAxisDirection}\index{pk\_src.adjustAxisDirection (module)}
Calculates the projection of all points in currently selected mesh onto a given axis. Returns the given axis or its inverse depending on the distribution of projected points: if more points lie `above' the median (based on the range of all point) then axis itself will be returned, if more points lie `below' median then inverse of axis is returned. Main purpose is to use this function on one of the main axes.
Command only accepts `transform' nodes. Command will only use first object in current selection.

\textbf{command:} cmds.adjustAxisDirection({[}obj{]}, axis)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{axis(a)}] \leavevmode
vector as list of 3 values where object's points are projected to (e.g. {[}1,0,0{]})

\end{description}\end{quote}

\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyPyramid}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} [u\PYGZsq{}pPyramid1\PYGZsq{}, u\PYGZsq{}polyPyramid1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{adjustAxisDirection}\PYG{p}{(}\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [\PYGZhy{}0.0, \PYGZhy{}1.0, \PYGZhy{}0.0] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{axisParallelPlane}
\label{pk_src.axisParallelPlane:axisparallelplane}\label{pk_src.axisParallelPlane::doc}\label{pk_src.axisParallelPlane:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.axisParallelPlane:module-pk_src.axisParallelPlane}\index{pk\_src.axisParallelPlane (module)}
Inserts an axis parallel plane (app) with normal vector along x-,y- or z-axis to be tangential to the minimum/maximum vertex of a selected object (in the specified axis direction), i.e. the plane has exactly one contact point with the selected object in its minimum/maximum x, y or z direction. Additionally the position of the plane is set to be below/above the mesh object's center point.
The axis parallel plane can be calculated for one single time step or a complete animation. In case of a parent node with the type `joint' the keyframes will be automatically catched (whether the transform node or joint node is selected, the behaviour will be the same). If the first keyframe in the animation is `separated' from all other frames, i.e. the frame distance from first to second is much larger than from second to third frame, this first keyframe will be ignored in the calculation of the axis parallel plane.

\textbf{see also:} {\hyperref[pk_src.centerPoint:centerpoint]{\sphinxcrossref{\DUrole{std,std-ref}{centerPoint}}}}, {\hyperref[pk_src.altitudeMap:altitudemap]{\sphinxcrossref{\DUrole{std,std-ref}{altitudeMap}}}}

\textbf{command:} cmds.axisParallelPlane({[}obj{]}, plane = `yz', position = `min')
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{plane(p)}] \leavevmode
string (`xy', `xz', `yz') to specifiy plane direction (default `xz')

\item[{position(pos)}] \leavevmode
string (`min', `max') to specify if plane should be positioned at the minimal/maximal vertex position concerning the plane orientation (default `min')

\item[{anim(a)}] \leavevmode
boolean flag to indicate if plane should be calculated for the whole animation (True) or only for the current time step (default False)

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
name of created polyPlane object (name will be object name plus `\_app')

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{axisParallelPlane}\PYG{p}{(}\PYG{n}{p} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pos} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZus{}app\PYGZsq{}, u\PYGZsq{}polyPlane1\PYGZsq{}] \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} A new plane \PYGZsq{}pTorus1\PYGZus{}app\PYGZsq{} is inserted which is}
\PYG{c+c1}{\PYGZsh{} positioned under the torus (\PYGZhy{}0.5 units below world origin)}
\end{Verbatim}

\end{description}


\section{altitudeMap}
\label{pk_src.altitudeMap:altitudemap}\label{pk_src.altitudeMap::doc}\label{pk_src.altitudeMap:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.altitudeMap:module-pk_src.altitudeMap}\index{pk\_src.altitudeMap (module)}
Uses an axis parallel plane (app) and the object model connected to this plane to create an altitude map, i.e. a set of perpendicular distances from the faces of the object to the plane. The distance is measures from the plane to the centroid of each face. A ray is constructed from each of the faces to the plane and only those faces without any other intersection than the plane (only faces directly visible from the plane) are considered part of the altitude map.
Points with a larger distance than a given threshold will be discarded.

\textbf{see also:} {\hyperref[pk_src.axisParallelPlane:axisparallelplane]{\sphinxcrossref{\DUrole{std,std-ref}{axisParallelPlane}}}}

\textbf{command:} cmds.altitudeMap({[}obj, plane{]}, file = ``'', threshold = 10.0)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{file(f)}] \leavevmode
path to save altitude map to ASCII-file; if string is empty, no data will be written

\item[{threshold(t)}] \leavevmode
threshold of maximum distance from plane; all points with larger distance will be discarded (default 10.0)

\item[{anim(a)}] \leavevmode
boolean flag to indicate if altitude map shall be calculation for each frame (TRUE) or only for the current frame (FALSE, default). If TRUE a file name needs to be specified, because the amount of data could massively slow down maya if its only kept in work memory.

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
list of centroid points of faces, their indices in the mesh vtx-list and their distances to the plane, i.e. `{[}{[}n\_1, x\_1, y\_1, z\_1, d\_1{]}, {[}n\_2, x\_2, y\_2, z\_2, d\_2{]}, ...{]}'

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{xform}\PYG{p}{(}\PYG{n}{ro} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{axisParallelPlane}\PYG{p}{(}\PYG{n}{p} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pos} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZus{}app\PYGZsq{}, u\PYGZsq{}polyPlane1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTriangulate}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}polyTriangulate1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{altitudeMap}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pCube1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pCube1\PYGZus{}app}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [[4, \PYGZhy{}0.3983890351647723, 0.0597721458595899, \PYGZhy{}0.3785089467837944, 0.7449914933365491],}
\PYG{c+c1}{\PYGZsh{} [5, 0.019866728794979728, \PYGZhy{}0.07780045709588722, \PYGZhy{}0.5469076316145288, 0.607418890381072],}
\PYG{c+c1}{\PYGZsh{} [6, 0.021764807311746848, \PYGZhy{}0.5225944965679014, \PYGZhy{}0.1788206947620432, 0.16262485090905787],}
\PYG{c+c1}{\PYGZsh{} [7, 0.4192048032181355, \PYGZhy{}0.3599696226914842, 0.01564478359550836, 0.32524972478547504],}
\PYG{c+c1}{\PYGZsh{} [10, \PYGZhy{}0.3964909566480051, \PYGZhy{}0.3850218936124242, \PYGZhy{}0.010422009931308688, 0.300197453864535],}
\PYG{c+c1}{\PYGZsh{} [11, \PYGZhy{}0.4173067247013684, \PYGZhy{}0.08482441678052995, 0.35244215325697736, 0.6003949306964292]] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{alignObj}
\label{pk_src.alignObj::doc}\label{pk_src.alignObj:alignobj}\label{pk_src.alignObj:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.alignObj:module-pk_src.alignObj}\index{pk\_src.alignObj (module)}
Calculates the eigenvectors of the current object, inserts one extra column and row and returns a 4x4 transformation matrix as 16 float-values. The eigenvectors are calculated in another function called {\hyperref[pk_src.eigenvector:eigenvector]{\sphinxcrossref{\DUrole{std,std-ref}{eigenvector}}}}.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{see also:} {\hyperref[pk_src.eigenvector:eigenvector]{\sphinxcrossref{\DUrole{std,std-ref}{eigenvector}}}}, {\hyperref[pk_src.normalize:normalize]{\sphinxcrossref{\DUrole{std,std-ref}{normalize}}}}

\textbf{command:} cmds.alignObj({[}obj{]}, axisOrder = `yzx', fast = False)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{axisOrder(ao)}] \leavevmode
string to define axis order of eigenvectors (default `yzx')

\item[{fast(f)}] \leavevmode
boolean flag to indicate if calculation should use convex hull (faster but inaccurate)

\end{description}\end{quote}

\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{alignObj}\PYG{p}{(}\PYG{n}{ao} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xyz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [0.609576559498125, 0.7927272028323672, \PYGZhy{}5.465342261024642e\PYGZhy{}10, 0.0, \PYGZhy{}1.3544498855821985e\PYGZhy{}09, 3.520841396209562e\PYGZhy{}10, \PYGZhy{}1.0, 0.0, \PYGZhy{}0.7927272028323671, 0.6095765594981248, 1.288331507658196e\PYGZhy{}09, 0.0, 0.0, 0.0, 0.0, 1.0] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{xform}\PYG{p}{(}\PYG{n}{m} \PYG{o}{=} \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{alignObj}\PYG{p}{(}\PYG{n}{ao} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xyz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} torus is positioned \PYGZsq{}upwards\PYGZsq{} in x\PYGZhy{}y\PYGZhy{}plane}
\end{Verbatim}

\end{description}


\section{centerPoint}
\label{pk_src.centerPoint:centerpoint}\label{pk_src.centerPoint::doc}\label{pk_src.centerPoint:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.centerPoint:module-pk_src.centerPoint}\index{pk\_src.centerPoint (module)}
Calculates the average of all points (vertices of mesh) of current selection. This command is useful to define the origin of an arbitrary object's local coordinate frame.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{see also:} {\hyperref[pk_src.centroidPoint:centroidpoint]{\sphinxcrossref{\DUrole{std,std-ref}{centroidPoint}}}}, {\hyperref[pk_src.axisParallelPlane:axisparallelplane]{\sphinxcrossref{\DUrole{std,std-ref}{axisParallelPlane}}}}, {\hyperref[pk_src.normalize:normalize]{\sphinxcrossref{\DUrole{std,std-ref}{normalize}}}}, {\hyperref[pk_src.exportData:exportdata]{\sphinxcrossref{\DUrole{std,std-ref}{exportData}}}}

\textbf{command:} cmds.centerPoint({[}obj{]})
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{centerPoint}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [\PYGZhy{}8.046627044677735e\PYGZhy{}09, \PYGZhy{}5.513429641723633e\PYGZhy{}08, \PYGZhy{}1.1246651411056519e\PYGZhy{}07] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyPyramid}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pPyramid1\PYGZsq{}, u\PYGZsq{}polyPyramid1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{centerPoint}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [1.2363445733853951e\PYGZhy{}08, \PYGZhy{}0.21213203072547912, \PYGZhy{}1.2363447865482158e\PYGZhy{}08] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{centroidPoint}
\label{pk_src.centroidPoint:centroidpoint}\label{pk_src.centroidPoint::doc}\label{pk_src.centroidPoint:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.centroidPoint:module-pk_src.centroidPoint}\index{pk\_src.centroidPoint (module)}
Calculates the weighted average of all triangle centroids of current selection. This command is useful to define the origin of an arbitrary object's local coordinate frame in case of irregular triangulation of the object's mesh.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{see also:} {\hyperref[pk_src.centerPoint:centerpoint]{\sphinxcrossref{\DUrole{std,std-ref}{centerPoint}}}}

\textbf{command:} cmds.centroidPoint({[}obj{]})
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{centroidPoint}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [8.981527616005896e\PYGZhy{}10, \PYGZhy{}9.250593323493368e\PYGZhy{}08, \PYGZhy{}3.1820641749655423e\PYGZhy{}07] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyPyramid}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pPyramid1\PYGZsq{}, u\PYGZsq{}polyPyramid1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{centroidPoint}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [8.125617691761175e\PYGZhy{}09, \PYGZhy{}0.20412414173849558, \PYGZhy{}8.125620434757627e\PYGZhy{}09] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{centerPoint}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{description}


\section{cleanup}
\label{pk_src.cleanup:cleanup}\label{pk_src.cleanup::doc}\label{pk_src.cleanup:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.cleanup:module-pk_src.cleanup}\index{pk\_src.cleanup (module)}
Main purpose of this command is the extraction of the outer shell of an arbitrary object. Natural bones may have
natural inclusions due to air bubbles, blood vessels or imaging errors. During animation these inclusions can obstruct a clear view when the bone model is set half-transparent and inflate computation time. To extract only the outer bone shell one needs to delete all separate inclusions and possibly cut through `connecting tubes', i.e. small blood vessels connecting an outer shell with an inner shell. A threshold can be set to determine and delete all triangles of the bone model whose normal's distance (orthogonal distance from center point of triangle) to the next triangle is smaller than this threshold.

The command implements a button \emph{clean} under the shelf tab `ProKlaue', where one can find and list all shells of a currently selected transform node. The shells can then be selected to show which part of the bone model is part of this shell. A number behind each shell indicates the amount of triangles inside each set and finally one shell can be extracted, so that all other shells and their triangles will be deleted from the mesh.

The command primarily handles all the user interaction inside maya and processes output of commands {\hyperref[pk_src.getShells:getshells]{\sphinxcrossref{\DUrole{std,std-ref}{getShells}}}} and {\hyperref[pk_src.findTubeFaces:findtubefaces]{\sphinxcrossref{\DUrole{std,std-ref}{findTubeFaces}}}}.

\textbf{Command should only be used over the button interface}


\section{convexHull}
\label{pk_src.convexHull::doc}\label{pk_src.convexHull:convexhull}\label{pk_src.convexHull:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.convexHull:module-pk_src.convexHull}\index{pk\_src.convexHull (module)}
Calculates the convex hull using the scipy-library (based on \emph{Qhull}) of the current object and creates a new transform node. The name of the new transform node will be the object's name with the suffix `\_ch'
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{command:} cmds.convexHull({[}obj{]})
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
name of transform node with convex hull mesh

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{convexHull}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: pTorus1\PYGZus{}ch \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{coordinateSystem}
\label{pk_src.coordinateSystem::doc}\label{pk_src.coordinateSystem:coordinatesystem}\label{pk_src.coordinateSystem:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.coordinateSystem:module-pk_src.coordinateSystem}\index{pk\_src.coordinateSystem (module)}
Initializes a local coordinate system for the given object consisting of 3 colored axes. Will be grouped under the given transform object. Can be used in the export-command instead of the normalized position.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{see also:} {\hyperref[pk_src.normalize:normalize]{\sphinxcrossref{\DUrole{std,std-ref}{normalize}}}}, {\hyperref[pk_src.exportData:exportdata]{\sphinxcrossref{\DUrole{std,std-ref}{exportData}}}}

\textbf{command:} cmds.coordinateSystem({[}obj{]}, ao = `yzx', f = False)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{axisOrder(ao)}] \leavevmode
string with axis ordering of eigenvectors (default `yzx')

\item[{fast(f)}] \leavevmode
flag to indicate if covariance matrix should use the convex hull (True) or all points (False) (default True)

\end{description}\end{quote}

\end{description}


\section{delaunay}
\label{pk_src.delaunay:delaunay}\label{pk_src.delaunay::doc}\label{pk_src.delaunay:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.delaunay:module-pk_src.delaunay}\index{pk\_src.delaunay (module)}
Calculates the 3D delaunay triangulation (scipy library) on the vertices of a mesh object to have a real 3D solid representation of a given object model. Because the delaunay triangulation in scipy returns an unsorted list of vertices for each tetrahedron, the vertices are reordered to comply with the implicit normal definition used in Maya Autodesk. The result will be the triangulated convex hull of the given object mesh.

Command currently only returns a list of strings where each string encodes the vertices of one tetrahedron (as flattened 1D list) with its correct vertex order for an implicit normal definition (all normals are pointing away from center point of tetrahedron). That means, that the result needs to be converted to matrices (nested lists) again using `numpy.fromstring(str, sep='','').reshape(4,3)' for each string `str' in the returned list. The reason for this behavior is the fact, that one cannot return nested lists in Maya commands and the only workaround is to cast them to strings first.

Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{command:} cmds.delaunay({[}obj{]})
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
list of tetrahedrons as strings (each string represents 4 vertices with 3 points each separated by `,'. Numbers {[}0:3{]} are first vertex, {[}3:6{]} second vertex, ...)

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{delaunay}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, 0.5, 0.5, 0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}, u\PYGZsq{}\PYGZhy{}0.5, 0.5, 0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, 0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}, u\PYGZsq{}0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}, u\PYGZsq{}\PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}, u\PYGZsq{}0.5, 0.5, \PYGZhy{}0.5, 0.5, 0.5, 0.5, \PYGZhy{}0.5, 0.5, 0.5, 0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}, u\PYGZsq{}\PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 0.5, 0.5, \PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, 0.5\PYGZsq{}] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{eigenvector}
\label{pk_src.eigenvector::doc}\label{pk_src.eigenvector:eigenvector}\label{pk_src.eigenvector:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.eigenvector:module-pk_src.eigenvector}\index{pk\_src.eigenvector (module)}
Calculates the eigenvectors and eigenvalues of the covariance matrix of all points in current object's mesh. The eigenvector with the largest eigenvalue corresponds to the first axis defined in axis order, second largest to second axis and third largest to third axis. Command is used by {\hyperref[pk_src.alignObj:alignobj]{\sphinxcrossref{\DUrole{std,std-ref}{alignObj}}}} and {\hyperref[pk_src.exportData:exportdata]{\sphinxcrossref{\DUrole{std,std-ref}{exportData}}}}.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

The calculation of the covariance matrix is defined as:
\begin{equation*}
\begin{split}C = [c_{i,j}] = \biggl[ \biggl (  \frac{1}{a^H}\sum\limits_{k=0}^{n-1}\frac{a^k}{12}(9m_i^km_j^k + p_i^kp_j^k + q_i^kq_j^k + r_i^kr_j^k) \biggr ) - m_i^Hm_j^H \biggr]\end{split}
\end{equation*}
where \(m^H = \frac {1}{a^H}\sum\limits_{k=0}^{n-1}a^km^k\) is the centroid of the convex hull with \(m^i = \frac{p^i+q^i+r^i}3\) as centroid of triangle \(i\) and the surface of the convex hull \(a^H = \sum\limits_{k=0}^{n-1}a^k\). The area of triangle \(k\) with its is vertices \(\Delta p^kq^kr^k\) is defined as \(a^k\).

The eigenvectors and eigenvalue of \(C\) are calculated using \emph{numpy.linalg.eigh}.

\textbf{see also:} {\hyperref[pk_src.alignObj:alignobj]{\sphinxcrossref{\DUrole{std,std-ref}{alignObj}}}}, {\hyperref[pk_src.exportData:exportdata]{\sphinxcrossref{\DUrole{std,std-ref}{exportData}}}}

\textbf{command:} cmds.eigenvector({[}obj{]}, ao = `yzx', f = False)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{axisOrder(ao)}] \leavevmode
string to define axis order of eigenvectors (default `yzx')

\item[{fast (f)}] \leavevmode
boolean flag to indicate if calculation should use convex hull; faster but inaccurate (default False)

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
list of 9 float values corresponding to first eigenvector ({[}0:3{]}), second eigenvector ({[}3:6{]}) and third eigenvector ({[}6:9{]})

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{eigenvector}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [5.465342261024642e\PYGZhy{}10, \PYGZhy{}0.609576559498125, 0.7927272028323672, 1.0, 1.3544498855821985e\PYGZhy{}09, 3.520841396209562e\PYGZhy{}10, \PYGZhy{}1.288331507658196e\PYGZhy{}09, 0.7927272028323671, 0.6095765594981248] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{exportData}
\label{pk_src.exportData:exportdata}\label{pk_src.exportData::doc}\label{pk_src.exportData:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.exportData:module-pk_src.exportData}\index{pk\_src.exportData (module)}
Exports the specified information for a list of objects for a whole animation. Information will be written to separate files. The file names will be the object names with a possible prefix. The files itself will contain a tab-separated table with one entry/row for each animation time step. Because the whole export runs in Maya's main thread, there is currently no possibility to cancel already started export commands and one needs to wait until the export is finished which, depending on the length of the animation and number of selected objects, can take a few minutes (to speed up the export with multiple models, one can move the camera away from the scene and all objects, so the rendering step runs much faster). The current progress of the export always shows the active time frame and for each selected object the whole animation will run through once.

All the information will be tracked via maya's space locators which sometimes may show unexpected behaviour. The space locators is not directly set inside the bone model but at the normalized position, where the bone model would be after the execution of the command {\hyperref[pk_src.normalize:normalize]{\sphinxcrossref{\DUrole{std,std-ref}{normalize}}}}. Alternatively the flag \emph{localCoordinateSystem} allows to define an arbitrary coordinate system which will be used instead of the automatically calculated one. This coordinate system needs to be grouped under the transform node of the current object. Additionally the normalized position of each bone model is taken in world coordinates from the first keyframe \textgreater{} 0, which may affect the overall orientation. Lastly, in combination with joint-hierarchies it does not matter, which object is selected (the transform bone model or the parent joint node), the script will automatically combine the keyframes of both transform node and joint node, find the transform node as child of the joint node (respectively the joint node as parent of the transform node) and apply all necessary transformations to the mesh object. Requirement for this behaviour to work is the explicit hierarchical order (joint nodes should have only ONE direct transform node as child and each transform node must have an unique parent joint node; to attach multiple transform nodes under a common ancestor, one needs to use intermediate joint nodes for each level of the hierarchy).

\textbf{see also:} {\hyperref[pk_src.normalize:normalize]{\sphinxcrossref{\DUrole{std,std-ref}{normalize}}}}, {\hyperref[pk_src.coordinateSystem:coordinatesystem]{\sphinxcrossref{\DUrole{std,std-ref}{coordinateSystem}}}}

\textbf{command:} cmds.exportData({[}obj{]}, p = ``'', fp = ``'', cm = ``centerPoint'', lcs = False, jh = False, f = False, tm = True, wt = True, wa = True, wr = True, ao = `yzx')
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{path(p)}] \leavevmode
path to target directory

\item[{filePrefix(fp)}] \leavevmode
prefix of all files

\item[{centerMethod(cm)}] \leavevmode
string `centerPoint' (default) to use average of all points as position, `centroidPoint' to use weighted mean of triangle centroid and area as position or `centerOBB' to use center of oriented bounding box as position (only when `align' is True)

\item[{localCoordinateSystem(lcs)}] \leavevmode
flag to indicate if objects have their own local coordinate system (True) or the normalized orientation (False) shall be used for export data (default False)

\item[{jointHierarchy(jh)}] \leavevmode
flag to indicate if objects are organized in an hierarchy (True) or are completely independent of each other (default False)

\item[{fast(f)}] \leavevmode
flag to indicate if covariance matrix should use the convex hull (True) or all points (False) (default FALSE)

\item[{writeTransformM(tm)}] \leavevmode
flag to indicate if transform matrix shall be written to file

\item[{writeTranslation(wt)}] \leavevmode
flag to indicate if translation shall be written to file

\item[{writeAngles(wa)}] \leavevmode
flag to indicate if projected angles shall be written to file (deprecated)

\item[{writeRotations(wr)}] \leavevmode
flag to indicate if rotation values shall be written to file (deprecated)

\item[{axisOrder(ao)}] \leavevmode
string with axis ordering of eigenvectors (default `yzx')

\item[{animationStart(as)}] \leavevmode
first time step where information shall be exported (default \emph{animationStartTime} of \textbf{playbackOptions})

\item[{animationEnd(ae)}] \leavevmode
last time step where information shall be exported (default \emph{animationEndTime} of \textbf{playbackOptions})

\item[{animationStep(by)}] \leavevmode
time difference between two animation frames (default \emph{by} of \textbf{playbackOptions})

\end{description}\end{quote}

\end{description}


\section{findTubeFaces}
\label{pk_src.findTubeFaces::doc}\label{pk_src.findTubeFaces:findtubefaces}\label{pk_src.findTubeFaces:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.findTubeFaces:module-pk_src.findTubeFaces}\index{pk\_src.findTubeFaces (module)}
Calculates the triangles of current object with an orthogonal distance to the next surface below a given threshold, which indicates a tube/tunnel to connect two shells of the object with each other. All those triangles will be selected and can be deleted by the standard user action.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{see also:} {\hyperref[pk_src.cleanup:cleanup]{\sphinxcrossref{\DUrole{std,std-ref}{cleanup}}}}, {\hyperref[pk_src.getShells:getshells]{\sphinxcrossref{\DUrole{std,std-ref}{getShells}}}}

\textbf{command:} cmds.findTubeFaces({[}obj{]}, t = 0.1)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{threshold(t)}] \leavevmode
threshold of orthogonal distance between triangles. All triangles closer to each other than this threshold will be selected (default 0.1)

\end{description}\end{quote}

\end{description}


\section{getShells}
\label{pk_src.getShells:getshells}\label{pk_src.getShells::doc}\label{pk_src.getShells:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.getShells:module-pk_src.getShells}\index{pk\_src.getShells (module)}
Calculates all shells of current selection and returns them as list of strings. One shell are all triangles which are connected, i.e. there exists a path from each triangle to all other triangles using common edges.
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

\textbf{command}: cmds.getShells({[}obj{]})
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
list of strings. Each string stands for one shell with a list of indices separated by comma and enclosed by `{[}...{]}', e.g. {[}'{[}0, 1, 2, 3, 4, ...{]}', `{[}...{]}', `{[}...{]}', ...{]}

\end{description}\end{quote}


\section{getVolume}
\label{pk_src.getVolume:getvolume}\label{pk_src.getVolume::doc}\label{pk_src.getVolume:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.getVolume:module-pk_src.getVolume}\index{pk\_src.getVolume (module)}
Calculates the volume of a polygonal object by using signed volumes.
All triangle faces of the mesh will be expanded to tetrahedra which are topped off at the origin (0,0,0). Sign of the volume is determined by the direction of the origin from the current face
(\href{http://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up}{source}).
Command only accepts `transform' nodes and will only be applied to the first object of the current selection.

There is a mel-command in Maya named \href{http://help.autodesk.com/cloudhelp/2016/ENU/Maya-Tech-Docs/Commands/computePolysetVolume.html}{computePolysetVolume} which calculates the volume of the selected object. The Maya command returns the exact same result (except numerical error \(< 10^{-5}\)) as this implementation but runs roughly 100 times slower.
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
float value with volume (based on maya's unit of length)

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{getVolume}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: 4.774580351278257 \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} MEL command}
\PYG{n}{computePolysetVolume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{makeIdentity} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{apply} \PYG{n}{true} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{n}{pn} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{pTorus2} \PYG{n}{faces} \PYG{o}{=} \PYG{l+m+mi}{400} \PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{TOTAL} \PYG{n}{VOLUME} \PYG{o}{=} \PYG{l+m+mf}{4.774580265} \PYG{o}{/}\PYG{o}{/}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Result}\PYG{p}{:} \PYG{l+m+mf}{4.77458} \PYG{o}{/}\PYG{o}{/}
\end{Verbatim}

\end{description}


\section{intersection}
\label{pk_src.intersection:intersection}\label{pk_src.intersection::doc}\label{pk_src.intersection:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.intersection:module-pk_src.intersection}\index{pk\_src.intersection (module)}
Calculates an approximate intersection volume of two transform objects by intersection of the tetrahedra given by the delaunay triangulation of the convex decomposition of both objects. Because the convex hull usually is a poor approximation of the original object, the \href{https://github.com/kmammou/v-hacd}{V-HACD} library is used to find an approximate convex decomposition of the object itself and then use the convex parts to create triangulated tetrahedra to approximate the intersection volume by pairwise intersection tests.

So both objects will be decomposed in convex parts, every part will be triangulated with the delaunay triangulation and their tetrahedra will be intersected pairwise. The sum of the intersection volume of all pairwise tetrahedra is the sum of the intersection of both convex decompositions. To speed up the calculation there is a first evaluation which determines all intersection candidates for a tetrahedron from the first convex hull with possible tetrahedra of the second convex hull. Candidates are all those tetrahedra which lie within or intersect the axis aligned bounding box (their minimal and maximal range in each axis need to overlap). Secondly there is a more accurate collision test with all the candidates which determines which candidates actually intersect the current tetrahedron (using the axis separating theorem, see {\hyperref[pk_src.collision_tet_tet:collision\string-tet\string-tet]{\sphinxcrossref{\DUrole{std,std-ref}{collision\_tet\_tet}}}}). Finally all remaining tetrahedra will be intersected and their intersection volume will be calculated (see {\hyperref[pk_src.intersection_tet_tet:intersection\string-tet\string-tet]{\sphinxcrossref{\DUrole{std,std-ref}{intersection\_tet\_tet}}}}).

All necessary functions are implemented without any Maya commands to speed up calculation; from past experience it can be concluded that Maya commands are much slower than a fresh implementation in Python.
An Interval Tree approach was tested and did not lead to performance improvements.

Command only accepts `transform' nodes and multiple objects can be selected. The output will be a matrix with the volume of the convex hulls for each object in the main diagonal and in the upper triangular matrix are the pairwise intersections between each combination of objects. Additionally the volumes of the objects itself (not their convex decompositions) will be printed during runtime.

The parameter arguments are the same as for the command {\hyperref[pk_src.vhacd:vhacd]{\sphinxcrossref{\DUrole{std,std-ref}{vhacd}}}} and will be simply handed down to the vhacd command invocation.

\textbf{see also:} {\hyperref[pk_src.collision_tet_tet:collision\string-tet\string-tet]{\sphinxcrossref{\DUrole{std,std-ref}{collision\_tet\_tet}}}}, {\hyperref[pk_src.intersection_tet_tet:intersection\string-tet\string-tet]{\sphinxcrossref{\DUrole{std,std-ref}{intersection\_tet\_tet}}}}, {\hyperref[pk_src.getVolume:getvolume]{\sphinxcrossref{\DUrole{std,std-ref}{getVolume}}}}, {\hyperref[pk_src.vhacd:vhacd]{\sphinxcrossref{\DUrole{std,std-ref}{vhacd}}}}

\textbf{command:} cmds.intersection({[}obj{]}, kcd = True)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{keepConvexDecomposition(kcd)}] \leavevmode
should the convex decompositions (intermediate data) be kept (True, default) or deleted (False)

\item[{tmp(temporaryDir)}] \leavevmode
directory to save temporary created files (needs read and write access). If no path is given the temporary files will be written into the user home directory

\item[{executable(exe)}] \leavevmode
absolute path to the executable V-HACD file. If no path is given maya/bin/plug-ins/bin/testVHACD is used.

\item[{resolution(res)}] \leavevmode
maximum number of voxels generated during the voxelization stage (10.000 - 64.000.000, default: 100.000)

\item[{depth(d)}] \leavevmode
maximum number of clipping stages. During each split stage, all the model parts (with a concavity higher than the user defined threshold) are clipped according the ``best'' clipping plane (1 - 32, default: 20)

\item[{concavity(con)}] \leavevmode
maximum concavity (0.0 - 1.0, default: 0.001)

\item[{planeDownsampling(pd)}] \leavevmode
controls the granularity of the search for the ``best'' clipping plane (1 - 16, default: 4)

\item[{convexHullDownsampling(chd)}] \leavevmode
controls the precision of the convex-hull generation process during the clipping plane selection stage (1 - 16, default: 4)

\item[{alpha(a)}] \leavevmode
controls the bias toward clipping along symmetry planes (0.0 - 1.0, default: 0.05)

\item[{beta(b)}] \leavevmode
controls the bias toward clipping along revolution axes (0.0 - 1.0, default: 0.05)

\item[{gamma(g)}] \leavevmode
maximum allowed concavity during the merge stage (0.0 - 1.0, default: 0.0005)

\item[{normalizeMesh(pca)}] \leavevmode
enable/disable normalizing the mesh before applying the convex decomposition (True/False, default: False)

\item[{mode(m)}] \leavevmode
voxel-based approximate convex decomposition (0, default) or tetrahedron-based approximate convex decomposition (1)

\item[{maxNumVerticesPerCH(vtx)}] \leavevmode
controls the maximum number of triangles per convex-hull (4 - 1024, default: 64)

\item[{minVolumePerCH(vol)}] \leavevmode
controls the adaptive sampling of the generated convex-hulls (0.0 - 0.01, default: 0.0001)

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
string containing a nxn matrix (n: number of objects) with intersection volumes.

\item[{raises RunTimeError}] \leavevmode
if volume of convex decomposition is smaller than volume of given object. Indicates that there are holes inside convex decomposition which obviously leads to incorrect results for the intersection volume. Solution is to choose smaller depth paramter

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus1\PYGZsq{}, u\PYGZsq{}polyTorus1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus2\PYGZsq{}, u\PYGZsq{}polyTorus2\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{xform}\PYG{p}{(}\PYG{n}{ro} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{makeIdentity}\PYG{p}{(}\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyTorus}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pTorus3\PYGZsq{}, u\PYGZsq{}polyTorus3\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{xform}\PYG{p}{(}\PYG{n}{ro} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{makeIdentity}\PYG{p}{(}\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{select} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{pTorus3} \PYG{n}{pTorus2} \PYG{n}{pTorus1} \PYG{p}{;}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{intersection}\PYG{p}{(}\PYG{n}{kcd} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{volume} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+m+mf}{4.77458035128}
\PYG{n}{volume} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mf}{4.77458035128}
\PYG{n}{volume} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+m+mf}{4.77458035128}
\PYG{c+c1}{\PYGZsh{} Result: [[ 5.97810349  1.91942589  1.92072237]}
 \PYG{p}{[} \PYG{l+m+mf}{0.}          \PYG{l+m+mf}{5.97378722}  \PYG{l+m+mf}{1.91621988}\PYG{p}{]}
 \PYG{p}{[} \PYG{l+m+mf}{0.}          \PYG{l+m+mf}{0.}          \PYG{l+m+mf}{5.97281007}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}}
\end{Verbatim}

\end{description}


\section{normalize}
\label{pk_src.normalize:normalize}\label{pk_src.normalize::doc}\label{pk_src.normalize:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.normalize:module-pk_src.normalize}\index{pk\_src.normalize (module)}
Normalize selected objects by aligning the eigenvectors of the covariance matrix to the world cordinate system and using the center point of each object as the origin of its local coordinate system.

\textbf{see also:} {\hyperref[pk_src.alignObj:alignobj]{\sphinxcrossref{\DUrole{std,std-ref}{alignObj}}}}, {\hyperref[pk_src.eigenvector:eigenvector]{\sphinxcrossref{\DUrole{std,std-ref}{eigenvector}}}}, {\hyperref[pk_src.centerPoint:centerpoint]{\sphinxcrossref{\DUrole{std,std-ref}{centerPoint}}}}, {\hyperref[pk_src.centroidPoint:centroidpoint]{\sphinxcrossref{\DUrole{std,std-ref}{centroidPoint}}}}

\textbf{command:} cmds.normalize({[}obj{]}, s = 1.0, tZ = True, pZ = True, a = True, ao = `yzx', f = False, cm = `centerPoint')
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{scale(s)}] \leavevmode
float value to scale all objects and their distance to the origin

\item[{transToZero(tZ)}] \leavevmode
flag to indicate if objects shall be translated to world space origin (0,0,0) or remain at their position (default True)

\item[{pivToZero(pZ)}] \leavevmode
flag to indicate if objects pivots shall be translated to world space origin (0,0,0) or remain at their position (default True)

\item[{align(a)}] \leavevmode
flag to indicate if object shall be aligned according to eigenvectors (default True)

\item[{axisOrder(ao)}] \leavevmode
string of length 3 with axis order (default `yzx'). Will only be considered if flag `align' is True

\item[{fast(f)}] \leavevmode
flag to indicate if covariance matrix shall be computing using all points (False) or only the points in the convex hull (True). Will only be considered if flag `align' is True (default False)

\item[{centerMethod(cm)}] \leavevmode
string `centerPoint' (default) to use average of all points as position, `centroidPoint' to use weighted mean of triangle centroid and area as position or `centerOBB' to use center of oriented bounding box as position (only when `align' is True)

\end{description}\end{quote}

\end{description}


\section{rangeObj}
\label{pk_src.rangeObj::doc}\label{pk_src.rangeObj:rangeobj}\label{pk_src.rangeObj:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.rangeObj:module-pk_src.rangeObj}\index{pk\_src.rangeObj (module)}
Calculates the projection of all points in currently selected mesh onto a given axis. Returns a list of 3 values with min{[}p.x + p.y + p.z{]}, max{[}p.x + p.y + p.z{]} and abs(max - min). Function's main purpose is to calculate the range of an object with respect to the x,y,z-axes.
Command only accepts `transform' nodes.

\textbf{command:} cmds.rangeObj({[}obj{]}, a)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{obj}] \leavevmode
string with object's name inside maya

\item[{axis(a)}] \leavevmode
vector as list of 3 values where object's point are projected to

\end{description}\end{quote}

\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyPyramid}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pPyramid1\PYGZsq{}, u\PYGZsq{}polyPyramid1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{rangeObj}\PYG{p}{(}\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [\PYGZhy{}0.3535533845424652, 0.3535533845424652, 0.7071067690849304] \PYGZsh{}}
\end{Verbatim}

\end{description}


\section{vhacd}
\label{pk_src.vhacd:vhacd}\label{pk_src.vhacd::doc}\label{pk_src.vhacd:id1}
{\hyperref[index:commands]{\sphinxcrossref{\DUrole{std,std-ref}{Command list}}}}
\phantomsection\label{pk_src.vhacd:module-pk_src.vhacd}\index{pk\_src.vhacd (module)}
Uses the V-HACD library (\url{https://github.com/kmammou/v-hacd}) to calculate an approximate convex decomposition for a number of selected or given objects. Because Maya's object representation is usually a surface mesh, it is sometimes necessary to convert the object to a solid geometry (especially when using complex objects or boolean operations). Using convex decomposition avoids problems concerning holes or non-manifold geometry. The original object will be approximated by a finite number of convex polyhedra organized in one group per original object.

The available properties and settings of V-HACD are taken directly from the \href{http://kmamou.blogspot.de/2014/12/v-hacd-20-parameters-description.html}{description page}.

Script makes use of the \emph{wrl2ma}-command under \emph{maya/bin} to parse to and from different formats. Apparently there are some old parser-inconsistencies which may produce warning or error messages, which (as far as observed) have no visible effect on the produces mesh. Also the path to the directories \emph{maya/bin} for \emph{wrl2ma} and \emph{plug-ins/bin} for V-HACD is guessed through the environment path variable of the operating system.

\textbf{NOTE:} There are observed cases where V-HACD was not able to create a real solid geometry for a given mesh (without any topological holes) but rather creates a convex decomposition where the summed volume of the convex parts is smaller than the volume of the original mesh, i.e. the decomposition creates a topologically different model where the inner area is hollow. Therefore one should always verify the output mesh and in case of a faulty decomposition choose different parameter settings (a smaller \emph{depth}-value usually avoids this problem).

\textbf{see also:} {\hyperref[pk_src.getVolume:getvolume]{\sphinxcrossref{\DUrole{std,std-ref}{getVolume}}}}, {\hyperref[pk_src.intersection:intersection]{\sphinxcrossref{\DUrole{std,std-ref}{intersection}}}}

\textbf{command:} cmds.vhacd({[}obj{]}, tmp = `\textasciitilde{}/', exe = `../maya/bin/plug-ins/bin/testVHACD', res = 100000, d = 20, con = 0.001, pd = 4, chd = 4, a = 0.05, b = 0.05, g = 0.0005, pca = False, m = 0, vtx = 64, vol = 0.0001)
\begin{description}
\item[{\textbf{Args:}}] \leavevmode\begin{quote}\begin{description}
\item[{tmp(temporaryDir)}] \leavevmode
directory to save temporary created files (needs read and write access). If no path is given the temporary files will be written into the user home directory

\item[{executable(exe)}] \leavevmode
absolute path to the executable V-HACD file. If no path is given maya/bin/plug-ins/bin/testVHACD is used.

\item[{resolution(res)}] \leavevmode
maximum number of voxels generated during the voxelization stage (10.000 - 64.000.000, default: 100.000)

\item[{depth(d)}] \leavevmode
maximum number of clipping stages. During each split stage, all the model parts (with a concavity higher than the user defined threshold) are clipped according the ``best'' clipping plane (1 - 32, default: 20)

\item[{concavity(con)}] \leavevmode
maximum concavity (0.0 - 1.0, default: 0.001)

\item[{planeDownsampling(pd)}] \leavevmode
controls the granularity of the search for the ``best'' clipping plane (1 - 16, default: 4)

\item[{convexHullDownsampling(chd)}] \leavevmode
controls the precision of the convex-hull generation process during the clipping plane selection stage (1 - 16, default: 4)

\item[{alpha(a)}] \leavevmode
controls the bias toward clipping along symmetry planes (0.0 - 1.0, default: 0.05)

\item[{beta(b)}] \leavevmode
controls the bias toward clipping along revolution axes (0.0 - 1.0, default: 0.05)

\item[{gamma(g)}] \leavevmode
maximum allowed concavity during the merge stage (0.0 - 1.0, default: 0.0005)

\item[{normalizeMesh(pca)}] \leavevmode
enable/disable normalizing the mesh before applying the convex decomposition (True/False, default: False)

\item[{mode(m)}] \leavevmode
voxel-based approximate convex decomposition (0, default) or tetrahedron-based approximate convex decomposition (1)

\item[{maxNumVerticesPerCH(vtx)}] \leavevmode
controls the maximum number of triangles per convex-hull (4 - 1024, default: 64)

\item[{minVolumePerCH(vol)}] \leavevmode
controls the adaptive sampling of the generated convex-hulls (0.0 - 0.01, default: 0.0001)

\end{description}\end{quote}

\end{description}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
list of Maya group names where each group corresponds with the approximate convex decomposition of one object (structure is: group name \textbar{} sub group \textbar{} convex mesh)

\end{description}\end{quote}


\chapter{Misc}
\label{index:sec-misc}\label{index:misc}

\section{collision\_tet\_tet}
\label{pk_src.collision_tet_tet:collision-tet-tet}\label{pk_src.collision_tet_tet::doc}\label{pk_src.collision_tet_tet:id1}
{\hyperref[index:sec\string-misc]{\sphinxcrossref{\DUrole{std,std-ref}{Misc}}}}
\phantomsection\label{pk_src.collision_tet_tet:module-pk_src.collision_tet_tet}\index{pk\_src.collision\_tet\_tet (module)}
Module to test for collision of two tetrahedra using the axis separating theorem.
Based on the paper \href{http://vcg.isti.cnr.it/Publications/2003/GPR03/fast\_tetrahedron\_tetrahedron\_overlap\_algorithm.pdf}{``Fast tetrahedron-tetrahedron overlap algorithm''} by F. Ganovelli, F. Ponchio and C. Rocchini.

Uses two lists of vertices for each tetrahedra. The class function Collision\_tet\_tet.check() returns True iff the two given tetrahedra actually intersect (or at least have common vertices).
Before calling `Collision\_tet\_tet.check()' the two tetrahedra need to be set with the methods \textbf{setV1}, \textbf{setV2} or \textbf{setV1V2}.
\index{Collision\_tet\_tet (class in pk\_src.collision\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pk\_src.collision\_tet\_tet.}\sphinxbfcode{Collision\_tet\_tet}}{\emph{tetra1=None}, \emph{tetra2=None}}{}
Initialize tetrahedra definitions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tetra1}} -- list of the 4 3D-vertices describing the first tetrahedron

\item {} 
\textbf{\texttt{tetra2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{itemize}

\end{description}\end{quote}
\index{check() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.check}\pysiglinewithargsret{\sphinxbfcode{check}}{}{}
Function to check if current two tetrahedra can intersect; optimized for speed.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True, iff the two tetrahedra intersect (or have common vertices).

\end{description}\end{quote}

\end{fulllineitems}

\index{separating\_plane\_edge\_A() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.separating_plane_edge_A}\pysiglinewithargsret{\sphinxbfcode{separating\_plane\_edge\_A}}{\emph{f0}, \emph{f1}}{}
Helper function for tetrahedron-tetrahedron collision: checks if edge is in the plane separating faces f0 and f1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coord}} -- 4x4 list of lists

\item {} 
\textbf{\texttt{self.masks}} -- 4x1 list of lists with single element

\item {} 
\textbf{\texttt{f0}} -- integer

\item {} 
\textbf{\texttt{f1}} -- integer

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{separating\_plane\_faceA\_1() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.separating_plane_faceA_1}\pysiglinewithargsret{\sphinxbfcode{separating\_plane\_faceA\_1}}{\emph{pv1}, \emph{n}, \emph{coord}, \emph{mask\_edges}}{}
Helper function for tetrahedron-tetrahedron collision test:
checks if plane pv1 is a separating plane. Stores local coordinates and the mask bit mask\_edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pv1}} -- vectors between vertices of second tetrahedron and vertex V{[}0{]} of first tetrahedron (list of lists {[}{[}...{]},{[}...{]},...{]})

\item {} 
\textbf{\texttt{n}} -- normal (list {[}x,y,z{]})

\item {} 
\textbf{\texttt{coord}} -- reference to list

\item {} 
\textbf{\texttt{mask\_edges}} -- reference to list with single element {[}m{]}

\end{itemize}

\item[{Returns}] \leavevmode
True if pv1 is a separating plane

\end{description}\end{quote}

\end{fulllineitems}

\index{separating\_plane\_faceA\_2() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.separating_plane_faceA_2}\pysiglinewithargsret{\sphinxbfcode{separating\_plane\_faceA\_2}}{\emph{n}, \emph{coord}, \emph{mask\_edges}}{}
Helper function for tetrahedron-tetrahedron collision test:
checks if plane v1,v2 is a separating plane. Stores local coordinates and the mask bit mask\_edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{V1}} -- list with vertices of tetrahedron 1

\item {} 
\textbf{\texttt{V2}} -- list with vertices of tetrahedron 2

\item {} 
\textbf{\texttt{n}} -- normal

\item {} 
\textbf{\texttt{coord}} -- reference to list

\item {} 
\textbf{\texttt{mask\_edges}} -- reference to list with single element {[}m{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{separating\_plane\_faceB\_1() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.separating_plane_faceB_1}\pysiglinewithargsret{\sphinxbfcode{separating\_plane\_faceB\_1}}{\emph{pv2}, \emph{n}}{}
\end{fulllineitems}

\index{separating\_plane\_faceB\_2() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.separating_plane_faceB_2}\pysiglinewithargsret{\sphinxbfcode{separating\_plane\_faceB\_2}}{\emph{n}}{}
\end{fulllineitems}

\index{setV1() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.setV1}\pysiglinewithargsret{\sphinxbfcode{setV1}}{\emph{V1}}{}
Set list of vertices for first tetrahedron.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{V1}} -- list of the 4 3D-vertices describing the first tetrahedron

\end{description}\end{quote}

\end{fulllineitems}

\index{setV1V2() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.setV1V2}\pysiglinewithargsret{\sphinxbfcode{setV1V2}}{\emph{V1}, \emph{V2}}{}
Set list of vertices for first and second tetrahedron.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{V1}} -- list of the 4 3D-vertices describing the first tetrahedron

\item {} 
\textbf{\texttt{V2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setV2() (pk\_src.collision\_tet\_tet.Collision\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.setV2}\pysiglinewithargsret{\sphinxbfcode{setV2}}{\emph{V2}}{}
Set list of vertices for second tetrahedron.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{V2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{description}\end{quote}

\end{fulllineitems}

\index{shifts (pk\_src.collision\_tet\_tet.Collision\_tet\_tet attribute)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.Collision_tet_tet.shifts}\pysigline{\sphinxbfcode{shifts}\sphinxstrong{ = {[}1, 2, 4, 8{]}}}
\end{fulllineitems}


\end{fulllineitems}

\index{cross() (in module pk\_src.collision\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.cross}\pysiglinewithargsret{\sphinxcode{pk\_src.collision\_tet\_tet.}\sphinxbfcode{cross}}{\emph{x}, \emph{y}}{}
cross product as lambda function to speed up calculations

\end{fulllineitems}

\index{dot() (in module pk\_src.collision\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.collision_tet_tet:pk_src.collision_tet_tet.dot}\pysiglinewithargsret{\sphinxcode{pk\_src.collision\_tet\_tet.}\sphinxbfcode{dot}}{\emph{x}, \emph{y}}{}
dot product as lambda function to speed up calculations

\end{fulllineitems}



\section{intersection\_tet\_tet}
\label{pk_src.intersection_tet_tet:intersection-tet-tet}\label{pk_src.intersection_tet_tet::doc}\label{pk_src.intersection_tet_tet:id1}
{\hyperref[index:sec\string-misc]{\sphinxcrossref{\DUrole{std,std-ref}{Misc}}}}
\phantomsection\label{pk_src.intersection_tet_tet:module-pk_src.intersection_tet_tet}\index{pk\_src.intersection\_tet\_tet (module)}
Module to to calculate 3D intersection of two tetrahedra.
The second tetrahedron will be clipped against the first tetrahedron with a simplified sutherland-hodgman approach.
\index{centroid\_tri() (in module pk\_src.intersection\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.centroid_tri}\pysiglinewithargsret{\sphinxcode{pk\_src.intersection\_tet\_tet.}\sphinxbfcode{centroid\_tri}}{\emph{v1}, \emph{v2}, \emph{v3}}{}
centroid of tri (3 3D-points) as lambda function to speed up calculation

\end{fulllineitems}

\index{cross() (in module pk\_src.intersection\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.cross}\pysiglinewithargsret{\sphinxcode{pk\_src.intersection\_tet\_tet.}\sphinxbfcode{cross}}{\emph{x}, \emph{y}}{}
cross product as lambda function to speed up calculation

\end{fulllineitems}

\index{dot() (in module pk\_src.intersection\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.dot}\pysiglinewithargsret{\sphinxcode{pk\_src.intersection\_tet\_tet.}\sphinxbfcode{dot}}{\emph{x}, \emph{y}}{}
dot product as lambda function to speed up calculation

\end{fulllineitems}

\index{intersection\_tet\_tet (class in pk\_src.intersection\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pk\_src.intersection\_tet\_tet.}\sphinxbfcode{intersection\_tet\_tet}}{\emph{tetra1=None}, \emph{tetra2=None}}{}
Class to initialize tetrahedra and set normals and centroids
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tetra1}} -- list of the 4 3D-vertices describing the first tetrahedron

\item {} 
\textbf{\texttt{tetra2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{itemize}

\end{description}\end{quote}
\index{intersect() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.intersect}\pysiglinewithargsret{\sphinxbfcode{intersect}}{}{}
Intersection calculation according to simplified sutherland-hodgman approach. Clip the second tetrahedron against the first one. At the end the triangles of the convex hull of all vertices will be returned
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of triangles with 3D-coordinates which form the 3D convex intersection volume

\end{description}\end{quote}

\end{fulllineitems}

\index{setCentroid() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.setCentroid}\pysiglinewithargsret{\sphinxbfcode{setCentroid}}{}{}
Calculate centroids of tetrahedron for each 4 facets.

\end{fulllineitems}

\index{setNormals() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.setNormals}\pysiglinewithargsret{\sphinxbfcode{setNormals}}{}{}
Calculate normals of tetrahedron for each 4 facets.

\end{fulllineitems}

\index{setV1() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.setV1}\pysiglinewithargsret{\sphinxbfcode{setV1}}{\emph{V1}}{}
Set list of vertices for first tetrahedron and set normals and centroids.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{V1}} -- list of the 4 3D-vertices describing the first tetrahedron

\end{description}\end{quote}

\end{fulllineitems}

\index{setV1V2() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.setV1V2}\pysiglinewithargsret{\sphinxbfcode{setV1V2}}{\emph{V1}, \emph{V2}}{}
Set list of vertices for first and second tetrahedron and set normals and centroids.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{V1}} -- list of the 4 3D-vertices describing the first tetrahedron

\item {} 
\textbf{\texttt{V2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setV2() (pk\_src.intersection\_tet\_tet.intersection\_tet\_tet method)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.intersection_tet_tet.setV2}\pysiglinewithargsret{\sphinxbfcode{setV2}}{\emph{V2}}{}
Set list of vertices for second tetrahedron.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{V2}} -- list of the 4 3D-vertices describing the second tetrahedron

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{normalize() (in module pk\_src.intersection\_tet\_tet)}

\begin{fulllineitems}
\phantomsection\label{pk_src.intersection_tet_tet:pk_src.intersection_tet_tet.normalize}\pysiglinewithargsret{\sphinxcode{pk\_src.intersection\_tet\_tet.}\sphinxbfcode{normalize}}{\emph{v}}{}
normalization of 3D-vector as lambda function to speed up calculation

\end{fulllineitems}



\section{misc}
\label{pk_src.misc:misc}\label{pk_src.misc::doc}\label{pk_src.misc:id1}
{\hyperref[index:sec\string-misc]{\sphinxcrossref{\DUrole{std,std-ref}{Misc}}}}
\phantomsection\label{pk_src.misc:module-pk_src.misc}\index{pk\_src.misc (module)}
Module with a few helper functions for plugin \emph{ProKlaue}.
\index{areaTriangle() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.areaTriangle}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{areaTriangle}}{\emph{vertices}}{}
Returns the area of a triangle given its three vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vertices}} -- list of 3 vertices defining the triangle

\item[{Returns}] \leavevmode
float value with area of triangle

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{p}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{y}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{z}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{misc}\PYG{o}{.}\PYG{n}{getPoints}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{areaTriangle}\PYG{p}{(}\PYG{p}{[}\PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: 0.5 \PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{centroidTriangle() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.centroidTriangle}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{centroidTriangle}}{\emph{vertices}}{}
Returns the centroid of a triangle given its three vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vertices}} -- list of 3 vertices defining the triangle

\item[{Returns}] \leavevmode
list of 3 float values representing the 3D-coordinates of the triangle's centroid

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{p}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{y}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{z}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{misc}\PYG{o}{.}\PYG{n}{getPoints}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{centroidTriangle}\PYG{p}{(}\PYG{p}{[}\PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [\PYGZhy{}0.16666666666666666, \PYGZhy{}0.16666666666666666, 0.5] \PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{getArgObj() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.getArgObj}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{getArgObj}}{\emph{syntax}, \emph{argList}}{}
Method to return list of objects from argument list (throws exception if no object is given or selected).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{syntax}} (\emph{\texttt{OpenMaya.MSyntax (api 1.0)}}) -- Function to syntax definition of current command

\item {} 
\textbf{\texttt{argList}} -- Argument list for command

\end{itemize}

\item[{Raises}] \leavevmode
\textbf{\texttt{AttributeError}} -- Raised when no object is selected

\item[{Returns}] \leavevmode
list of object names in argument list (or from current selection)

\end{description}\end{quote}

\end{fulllineitems}

\index{getFaceNormals() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.getFaceNormals}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{getFaceNormals}}{\emph{obj}, \emph{worldSpace=True}}{}
Method to return all face normals. Uses the command \href{http://download.autodesk.com/us/maya/2011help/Commands/polyInfo.html}{polyInfo} to access the normal information as string and parse them to a numpy array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{obj}} (\emph{\texttt{string}}) -- name of object

\item[{Returns}] \leavevmode
list of numpy arrays with the 3 float values for each normal

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{getFaceNormals}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [0.0, 0.0, \PYGZhy{}1.0], [0.0, \PYGZhy{}1.0, 0.0], [1.0, 0.0, 0.0], [\PYGZhy{}1.0, 0.0, 0.0]] \PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{getMesh() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.getMesh}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{getMesh}}{\emph{obj}}{}
Method to return mesh object from dag path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{obj}} (\emph{\texttt{string}}) -- name of object

\item[{Returns}] \leavevmode
MFnMesh object (api 2.0)

\end{description}\end{quote}

\end{fulllineitems}

\index{getPoints() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.getPoints}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{getPoints}}{\emph{obj}, \emph{mfnObject=None}, \emph{worldSpace=True}}{}
Method to return MPointArray with points of object's mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{obj}} (\emph{\texttt{string}}) -- name of object

\item {} 
\textbf{\texttt{mfnObject}} (\emph{\texttt{MFnMesh}}) -- mesh object

\item {} 
\textbf{\texttt{worldSpace}} (\emph{\texttt{Boolean}}) -- should coordinates be in world space (with transform) or in local space (without transform); default True

\end{itemize}

\item[{Returns}] \leavevmode
MPointArray (api 2.0)

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{xform}\PYG{p}{(}\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} vertices in local space (without transform)}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{getPoints}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{worldSpace} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: maya.api.OpenMaya.MPointArray([maya.api.OpenMaya.MPoint(\PYGZhy{}0.5, \PYGZhy{}0.5, 0.5, 1), maya.api.OpenMaya.MPoint(0.5, \PYGZhy{}0.5, 0.5, 1), maya.api.OpenMaya.MPoint(\PYGZhy{}0.5, 0.5, 0.5, 1), maya.api.OpenMaya.MPoint(0.5, 0.5, 0.5, 1), maya.api.OpenMaya.MPoint(\PYGZhy{}0.5, 0.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(0.5, 0.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(\PYGZhy{}0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(0.5, \PYGZhy{}0.5, \PYGZhy{}0.5, 1)]) \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} vertices in world space (with transform)}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{getPoints}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{worldSpace} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: maya.api.OpenMaya.MPointArray([maya.api.OpenMaya.MPoint(1.5, 0.5, 0.5, 1), maya.api.OpenMaya.MPoint(2.5, 0.5, 0.5, 1), maya.api.OpenMaya.MPoint(1.5, 1.5, 0.5, 1), maya.api.OpenMaya.MPoint(2.5, 1.5, 0.5, 1), maya.api.OpenMaya.MPoint(1.5, 1.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(2.5, 1.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(1.5, 0.5, \PYGZhy{}0.5, 1), maya.api.OpenMaya.MPoint(2.5, 0.5, \PYGZhy{}0.5, 1)]) \PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{getTriangles() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.getTriangles}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{getTriangles}}{\emph{obj}, \emph{mfnObject=None}}{}
Method to return all triangles in object mesh as nested list. Length of list is equal to number of triangles for the object. Each list element is another list of 3 vertex indices which refer to the point set of the current object mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{obj}} (\emph{\texttt{string}}) -- name of object

\item {} 
\textbf{\texttt{mfnObject}} (\emph{\texttt{MFnMesh}}) -- mesh object

\end{itemize}

\item[{Returns}] \leavevmode
numpy.ndarray (e.g. array({[}{[}2,1,3{]},{[}2,3,4{]},{[}4,3,5{]},{[}4,5,6{]},...{]}) for a polygon cube)

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{getTriangles}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: array([[0, 1, 2],}
       \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{project() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.project}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{project}}{\emph{p}, \emph{v}}{}
Orthogonal projection of one vector onto another.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p}} (\emph{\texttt{{[}x,y,z{]}}}) -- vector to be projected

\item {} 
\textbf{\texttt{v}} (\emph{\texttt{{[}x,y,z{]}}}) -- vector where p shall be projected to

\end{itemize}

\item[{Returns}] \leavevmode
orthogonal projection vector {[}x,y,z{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{signedVolumeOfTriangle() (in module pk\_src.misc)}

\begin{fulllineitems}
\phantomsection\label{pk_src.misc:pk_src.misc.signedVolumeOfTriangle}\pysiglinewithargsret{\sphinxcode{pk\_src.misc.}\sphinxbfcode{signedVolumeOfTriangle}}{\emph{p1, p2, p3, center={[}0, 0, 0{]}}}{}
Calculates signed volume of given triangle (volume of tetrahedron with triangle topped off at origin (0,0,0))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p1}} (\emph{\texttt{{[}x,y,z{]}}}) -- first point of triangle

\item {} 
\textbf{\texttt{p2}} (\emph{\texttt{{[}x,y,z{]}}}) -- second point of triangle

\item {} 
\textbf{\texttt{p3}} (\emph{\texttt{{[}x,y,z{]}}}) -- third point of triangle

\item {} 
\textbf{\texttt{center}} (\emph{\texttt{{[}x,y,z{]}}}) -- top of tetrahedron (default (0,0,0))

\end{itemize}

\item[{Returns}] \leavevmode
signed volume of tetrahedron

\end{description}\end{quote}
\begin{description}
\item[{\textbf{Example:}}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pk\PYGZus{}src} \PYG{k+kn}{import} \PYG{n}{misc}
\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{polyCube}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: [u\PYGZsq{}pCube1\PYGZsq{}, u\PYGZsq{}polyCube1\PYGZsq{}] \PYGZsh{}}
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{p}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{y}\PYG{p}{,} \PYG{n}{p}\PYG{o}{.}\PYG{n}{z}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{misc}\PYG{o}{.}\PYG{n}{getPoints}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{misc}\PYG{o}{.}\PYG{n}{signedVolumeOfTriangle}\PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: 0.08333333333333333 \PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} Volume of whole object}
\PYG{n}{triangles} \PYG{o}{=} \PYG{n}{misc}\PYG{o}{.}\PYG{n}{getTriangles}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pCube1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{,} \PYG{p}{[}\PYG{n}{misc}\PYG{o}{.}\PYG{n}{signedVolumeOfTriangle}\PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{n}{tri}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{tri}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{tri}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{tri} \PYG{o+ow}{in} \PYG{n}{triangles}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Result: 1.0 \PYGZsh{}}
\end{Verbatim}

\end{description}

\end{fulllineitems}



\chapter{HowTo: Add new commands to plugin \emph{ProKlaue}}
\label{index:howto-add-new-commands-to-plugin-proklaue}
The file \emph{proKlaue.py} is the master-file of the plugin where all submodules will be individually imported and registered as commands. To keep the general structure and clarity one should always use separate files/modules for each new command. Additionally the file name, module name and command name should be equal to simplify the registration steps.

To add a new command \emph{cmds.foo} implemented in the source file \emph{foo.py} to the plugin, one only needs to add the name \emph{foo} to the list of commands \emph{kPluginCmdName} in \emph{proKlaue.py} (l. 57) and it will be automatically imported, registered with syntax and button definition:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{kPluginCmdName} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{centerPoint}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{centroidPoint}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{normalize}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eigenvector}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alignObj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exportData}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rangeObj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{convexHull}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{getShells}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{findTubeFaces}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cleanup}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{getVolume}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{delaunay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{intersection}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adjustAxisDirection}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{vhacd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{foo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

The necessary parts of a new command need to be defined in a source file \emph{foo.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{maya.OpenMayaMPx} \PYG{k+kn}{as} \PYG{n+nn}{OpenMayaMPx}
\PYG{k+kn}{import} \PYG{n+nn}{maya.OpenMaya} \PYG{k+kn}{as} \PYG{n+nn}{om}
\PYG{k+kn}{import} \PYG{n+nn}{maya.cmds} \PYG{k+kn}{as} \PYG{n+nn}{cmds}
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{partial}

\PYG{k}{class} \PYG{n+nc}{foo}\PYG{p}{(}\PYG{n}{OpenMayaMPx}\PYG{o}{.}\PYG{n}{MPxCommand}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{windowID} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wFoo}\PYG{l+s+s2}{\PYGZdq{}}

   \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{OpenMayaMPx}\PYG{o}{.}\PYG{n}{MPxCommand}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

   \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}cancelCallback}\PYG{p}{(}\PYG{o}{*}\PYG{n}{pArgs}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{window}\PYG{p}{(}\PYG{n}{exportData}\PYG{o}{.}\PYG{n}{windowID}\PYG{p}{,} \PYG{n}{exists} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{deleteUI}\PYG{p}{(}\PYG{n}{exportData}\PYG{o}{.}\PYG{n}{windowID}\PYG{p}{)}

   \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}applyCallback}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{textF}\PYG{p}{,} \PYG{o}{*}\PYG{n}{pArgs}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{options} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{cmds}\PYG{o}{.}\PYG{n}{textField}\PYG{p}{(}\PYG{n}{textF}\PYG{p}{,} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{text} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
      \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{foo}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{options}\PYG{p}{)}

   \PYG{k}{def} \PYG{n+nf}{createUI} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{o}{*}\PYG{n}{pArgs}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{window}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{windowID}\PYG{p}{,} \PYG{n}{exists} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{deleteUI}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{windowID}\PYG{p}{)}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{window}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{windowID}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fooUI}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sizeable} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{resizeToFitChildren} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{rowColumnLayout}\PYG{p}{(}\PYG{n}{numberOfColumns} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
         \PYG{n}{text} \PYG{o}{=} \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{textField}\PYG{p}{(}\PYG{n}{visible} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{140}\PYG{p}{)}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{button}\PYG{p}{(}\PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{apply}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command} \PYG{o}{=} \PYG{n}{partial}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}applyCallback}\PYG{p}{,} \PYG{n}{text}\PYG{p}{)}\PYG{p}{,} \PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{p}{)}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{button}\PYG{p}{(}\PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cancel}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}cancelCallback}\PYG{p}{,} \PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{)}
         \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{showWindow}\PYG{p}{(}\PYG{p}{)}

   \PYG{k}{def} \PYG{n+nf}{doIt}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{argList}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{argData} \PYG{o}{=} \PYG{n}{om}\PYG{o}{.}\PYG{n}{MArgParser} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{syntax}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{argList}\PYG{p}{)}
      \PYG{n}{text} \PYG{o}{=} \PYG{n}{argData}\PYG{o}{.}\PYG{n}{flagArgumentString}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{k}{print}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{fooCreator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
   \PYG{k}{return} \PYG{n}{OpenMayaMPx}\PYG{o}{.}\PYG{n}{asMPxPtr}\PYG{p}{(} \PYG{n}{foo}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{fooSyntaxCreator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{syntax} \PYG{o}{=} \PYG{n}{om}\PYG{o}{.}\PYG{n}{MSyntax}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{syntax}\PYG{o}{.}\PYG{n}{addFlag}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{om}\PYG{o}{.}\PYG{n}{MSyntax}\PYG{o}{.}\PYG{n}{kString}\PYG{p}{)}
   \PYG{k}{return} \PYG{n}{syntax}
\PYG{k}{def} \PYG{n+nf}{addButton}\PYG{p}{(}\PYG{n}{parentShelf}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{cmds}\PYG{o}{.}\PYG{n}{shelfButton}\PYG{p}{(}\PYG{n}{parent} \PYG{o}{=} \PYG{n}{parentShelf}\PYG{p}{,} \PYG{n}{i} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pythonFamily.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{c}\PYG{o}{=}\PYG{n}{foo}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{createUI}\PYG{p}{,} \PYG{n}{imageOverlayLabel} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{foo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ann}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{do something}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

In this echo-server example a command button is defined with an input text field and two buttons (\emph{apply} and \emph{cancel}) inside the user interface. By pressing button \emph{apply} the text field content will be echoed to the console whereas \emph{cancel} closes the user interface. The same effect (without the user interface) can be achieved by typing \emph{cmds.foo(t = `echo')}.

All emphasized lines are required definitions: class \textbf{foo} inherited from \emph{OpenMayaMPx.MPxCommand}, its constructor \textbf{foo.\_\_init\_\_}, the function \textbf{foo.doIt} which will be triggered at command invocation, function \textbf{fooCreator} which just returns a pointer to a class instance, function \textbf{fooSyntaxCreator} which returns the syntax definition and function \textbf{addButton} where a shelf button under the shelf tab \emph{ProKlaue} can be defined. If no syntax definition is needed, the function \textbf{fooSyntaxCreator} still needs to return an object of type \emph{MSyntax}, otherwise the command registration will fail with an error message. Same applies to the function \textbf{addButton(parentShelf)}: if no button is needed, this function is still required for the registration step. See following case without syntax definition and shelf button:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fooSyntaxCreator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{syntax} \PYG{o}{=} \PYG{n}{om}\PYG{o}{.}\PYG{n}{MSyntax}\PYG{p}{(}\PYG{p}{)}
   \PYG{k}{return} \PYG{n}{syntax}
\PYG{k}{def} \PYG{n+nf}{addButton}\PYG{p}{(}\PYG{n}{parentShelf}\PYG{p}{)}\PYG{p}{:}
   \PYG{k}{pass}
\end{Verbatim}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pk\_src.adjustAxisDirection}}, \pageref{pk_src.adjustAxisDirection:module-pk_src.adjustAxisDirection}
\item {\texttt{pk\_src.alignObj}}, \pageref{pk_src.alignObj:module-pk_src.alignObj}
\item {\texttt{pk\_src.altitudeMap}}, \pageref{pk_src.altitudeMap:module-pk_src.altitudeMap}
\item {\texttt{pk\_src.axisParallelPlane}}, \pageref{pk_src.axisParallelPlane:module-pk_src.axisParallelPlane}
\item {\texttt{pk\_src.centerPoint}}, \pageref{pk_src.centerPoint:module-pk_src.centerPoint}
\item {\texttt{pk\_src.centroidPoint}}, \pageref{pk_src.centroidPoint:module-pk_src.centroidPoint}
\item {\texttt{pk\_src.cleanup}}, \pageref{pk_src.cleanup:module-pk_src.cleanup}
\item {\texttt{pk\_src.collision\_tet\_tet}}, \pageref{pk_src.collision_tet_tet:module-pk_src.collision_tet_tet}
\item {\texttt{pk\_src.convexHull}}, \pageref{pk_src.convexHull:module-pk_src.convexHull}
\item {\texttt{pk\_src.coordinateSystem}}, \pageref{pk_src.coordinateSystem:module-pk_src.coordinateSystem}
\item {\texttt{pk\_src.delaunay}}, \pageref{pk_src.delaunay:module-pk_src.delaunay}
\item {\texttt{pk\_src.eigenvector}}, \pageref{pk_src.eigenvector:module-pk_src.eigenvector}
\item {\texttt{pk\_src.exportData}}, \pageref{pk_src.exportData:module-pk_src.exportData}
\item {\texttt{pk\_src.findTubeFaces}}, \pageref{pk_src.findTubeFaces:module-pk_src.findTubeFaces}
\item {\texttt{pk\_src.getShells}}, \pageref{pk_src.getShells:module-pk_src.getShells}
\item {\texttt{pk\_src.getVolume}}, \pageref{pk_src.getVolume:module-pk_src.getVolume}
\item {\texttt{pk\_src.intersection}}, \pageref{pk_src.intersection:module-pk_src.intersection}
\item {\texttt{pk\_src.intersection\_tet\_tet}}, \pageref{pk_src.intersection_tet_tet:module-pk_src.intersection_tet_tet}
\item {\texttt{pk\_src.misc}}, \pageref{pk_src.misc:module-pk_src.misc}
\item {\texttt{pk\_src.normalize}}, \pageref{pk_src.normalize:module-pk_src.normalize}
\item {\texttt{pk\_src.rangeObj}}, \pageref{pk_src.rangeObj:module-pk_src.rangeObj}
\item {\texttt{pk\_src.vhacd}}, \pageref{pk_src.vhacd:module-pk_src.vhacd}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
