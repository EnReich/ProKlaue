<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pk_src.intersection &mdash; ProKlaue 0.2.8 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="ProKlaue 0.2.8 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pk_src.intersection</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Command cmds.intersection</span>

<span class="sd">Calculates the intersection of two transform objects by intersection of the tetrahedrons given by the delaunay triangulation of the convex hull of both objects. Because the convex hull usually is a poor approximation of the original object, the V-HACD library is used to find a approximate convex decomposition of the object itself and then use the covnex parts to approximate the intersection. So both objects will be triangulated and their tetrahedra will be intersected pairwise. The sum of the intersection volume of all pairwise tetrahedra is the sum of the intersection of both convex hulls. To speed up the calculation there is a first evaluation which determines all intersection candidates for a tetrahedron from the first convex hull with possible tetrahedra of the second convex hull. Candidates are all those tetrahedra which lie within or intersect the axis aligned bounding box (their minimal and maximal range in each axis need to overlap). Secondly there is a more accurate collision test with all the candidates which determines which candidates actually intersect the current tetrahedron (using the axis separating theorem). Finally all remaining tetrahedra will be intersected and their intersection volume will be calculated.</span>
<span class="sd">All necessary functions are implemented without any Maya commands to speed up calculation; from past experience it can be concluded that Maya commands are much slower than a fresh implementation in Python.</span>
<span class="sd">An Interval Tree approach was tested and did not lead to performance improvements.</span>
<span class="sd">Currently two convex hulls with about 14.000 tetrahedra each can be intersected in roughly 10 minutes but this strongly depends on the object itself and its triangulation.</span>

<span class="sd">Command only accepts &#39;transform&#39; nodes and multiple objects can be selected. The output will be a matrix with the volume of the convex hulls for each object in the main diagonal and in the upper triangular matrix are the pairwise intersections between each combination of objects. Additionally the volumes of the objects itself (not their convex hulls) will be printed during runtime.</span>

<span class="sd">Args:</span>
<span class="sd">    obj : string with object&#39;s name inside maya</span>
<span class="sd">    keepConvexDecomposition (kcd): should the convex decompositions (intermediate data) be kept (TRUE) or deleted (FALSE)</span>

<span class="sd">@return: string containing a nxn matrix (n: number of objects) with intersection volumes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">maya.OpenMayaMPx</span> <span class="kn">as</span> <span class="nn">OpenMayaMPx</span>
<span class="kn">import</span> <span class="nn">maya.OpenMaya</span> <span class="kn">as</span> <span class="nn">om</span>
<span class="kn">import</span> <span class="nn">maya.api.OpenMaya</span> <span class="kn">as</span> <span class="nn">om2</span>
<span class="kn">import</span> <span class="nn">maya.cmds</span> <span class="kn">as</span> <span class="nn">cmds</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">misc</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">pk_src</span> <span class="kn">import</span> <span class="n">collision_tet_tet</span>
<span class="kn">from</span> <span class="nn">pk_src</span> <span class="kn">import</span> <span class="n">intersection_tet_tet</span>
<span class="kn">from</span> <span class="nn">pk_src</span> <span class="kn">import</span> <span class="n">vhacd</span>

<span class="k">class</span> <span class="nc">intersection</span><span class="p">(</span><span class="n">OpenMayaMPx</span><span class="o">.</span><span class="n">MPxCommand</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">OpenMayaMPx</span><span class="o">.</span><span class="n">MPxCommand</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># make sure to use the newest version of the files (to avoid out-of-date definitions)</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;pk_src.collision_tet_tet&quot;</span><span class="p">])</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;pk_src.intersection_tet_tet&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">doIt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argList</span><span class="p">):</span>
        <span class="c1"># get objects from argument list (size &gt;= 2)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">getArgObj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">(),</span> <span class="n">argList</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Select at least 2 objects!&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">objectType</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="s1">&#39;transform&#39;</span> <span class="ow">or</span> <span class="n">cmds</span><span class="o">.</span><span class="n">objectType</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="s1">&#39;transform&#39;</span><span class="p">):</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Object is not of type transform!&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="c1"># check if given objects are the vhacd outputs</span>
            <span class="c1">#if (reduce(lambda x,y: x+y, [True for o in obj if re.search(&quot;_vhacd$&quot;,o)]) != len(obj)):</span>
            <span class="c1">#    cmds.error(&quot;Expected VHACD objects (group names ending with &#39;_vhacd[0-9]*&#39;)&quot;)</span>
            <span class="c1">#    return</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No objects selected or only one object given!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">argData</span> <span class="o">=</span> <span class="n">om</span><span class="o">.</span><span class="n">MArgParser</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">(),</span> <span class="n">argList</span><span class="p">)</span>

        <span class="c1"># read all arguments and set default values</span>
        <span class="n">keepCD</span> <span class="o">=</span> <span class="n">argData</span><span class="o">.</span><span class="n">flagArgumentBool</span><span class="p">(</span><span class="s1">&#39;keepConvexDecomposition&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">argData</span><span class="o">.</span><span class="n">isFlagSet</span><span class="p">(</span><span class="s1">&#39;keepConvexDecomposition&#39;</span><span class="p">))</span> <span class="k">else</span> <span class="bp">True</span>
        <span class="c1"># get all flags for vhacd over static parsing method</span>
        <span class="n">vhacd_par</span> <span class="o">=</span> <span class="n">vhacd</span><span class="o">.</span><span class="n">vhacd</span><span class="o">.</span><span class="n">readArgs</span><span class="p">(</span><span class="n">argData</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vhacd_par</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;V-HACD: one or more arguments are invalid!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># list of convexHulls (each list entry will be a list of convex parts of each object)</span>
        <span class="n">convexHulls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># get delaunay triangulation of each selected object and save results in list</span>
        <span class="c1"># delaunay[0:n] --&gt; object data; delaunay[i][0:m] --&gt; all tetrahedra of object i; delaunay[i][j][0:4] --&gt; 3D points of j-th tetrahedra of i-th object</span>
        <span class="n">delaunay</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get convex decomposition (cd) and save results in list (names of each group)</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">vhacd</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">vhacd_par</span><span class="p">)</span>

        <span class="c1"># for each convex decomposition get the actual mesh nodes and triangulate them</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cd</span><span class="p">):</span>
            <span class="c1"># actual mesh objects are child nodes of child groups under the main group</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listRelatives</span><span class="p">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">listRelatives</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="c1"># mesh itself has some corrupt triangle definition (only 1 triangle) --&gt; recalculate convex hull to avoid problems (probable cause: Maya 2012 ma-parser bug)</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmds</span><span class="o">.</span><span class="n">convexHull</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="k">for</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">]</span>
            <span class="c1"># add all convex hulls of one object to list of hulls (list of lists where each sub list contains the names of the convex hull decomposition parts)</span>
            <span class="n">convexHulls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span>

            <span class="c1"># get delaunay triangulation of each convex sub part as list of tetrahedra (tmp holds all tetrahedra of ONE single object; all convex hulls are put together without further distinction between sub parts)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">convexHulls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">extend</span> <span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">delaunay</span><span class="p">(</span><span class="n">ch</span><span class="p">)])</span>

            <span class="c1"># put all delaunay triangulations of each complete object together into list (list of objects where each object consists of a list of tetrahedra)</span>
            <span class="n">delaunay</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="c1"># preprocessing of min and max values in each dimension for each tetrahedra</span>
        <span class="n">x_minMax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_minMax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z_minMax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">delaunay</span><span class="p">:</span>
            <span class="n">x_minMax</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span>  <span class="k">for</span> <span class="n">tetra</span> <span class="ow">in</span> <span class="n">d</span> <span class="p">])</span>
            <span class="n">y_minMax</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])]</span>  <span class="k">for</span> <span class="n">tetra</span> <span class="ow">in</span> <span class="n">d</span> <span class="p">])</span>
            <span class="n">z_minMax</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">tetra</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])]</span>  <span class="k">for</span> <span class="n">tetra</span> <span class="ow">in</span> <span class="n">d</span> <span class="p">])</span>

        <span class="c1"># iterate over all pairwise object combinations and save volumes in nxn-table</span>
        <span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">)))</span>
        <span class="c1"># class object for collision test</span>
        <span class="n">colTest</span> <span class="o">=</span> <span class="n">collision_tet_tet</span><span class="o">.</span><span class="n">Collision_tet_tet</span><span class="p">()</span>
        <span class="c1"># class object for intersection</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">intersection_tet_tet</span><span class="o">.</span><span class="n">intersection_tet_tet</span><span class="p">()</span>
        <span class="c1"># flag to remember if convex hull volume is smaller than volume of object (indicates error in vhacd)</span>
        <span class="n">hullError</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># over each pair of objects</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">)):</span>
                <span class="c1"># if i equals j then just calculate volume of current object and volume of convex hull</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">vol</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">getVolume</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;volume {}: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vol</span><span class="p">))</span>
                    <span class="c1"># calc. volumes of each convex hull part and add up all values</span>
                    <span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">cmds</span><span class="o">.</span><span class="n">getVolume</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">convexHulls</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                    <span class="c1"># check volume against convex hull --&gt; indicates hole inside convex hull approximation</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">hullError</span> <span class="ow">and</span> <span class="n">vol</span> <span class="o">&gt;</span> <span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]):</span>
                        <span class="n">hullError</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">continue</span>
                <span class="c1"># over each pair of tetrahedra</span>
                <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="c1"># set tetrahedron of first object</span>
                    <span class="n">colTest</span><span class="o">.</span><span class="n">setV1</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">])</span>
                    <span class="n">inter</span><span class="o">.</span><span class="n">setV1</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">])</span>

                    <span class="c1"># get list of candidate tetrahedra, i.e. those tetrahedra whose bounding box overlaps with the bounding box of current tetrahedron</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">y_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">y_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">z_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">z_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">z</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">z_minMax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z_minMax</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">z</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>

                    <span class="c1"># check each candidate tetrahedra</span>
                    <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                        <span class="c1"># check if the two current tetrahedra can intersect each other</span>
                        <span class="n">colTest</span><span class="o">.</span><span class="n">setV2</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">n2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">colTest</span><span class="o">.</span><span class="n">check</span><span class="p">()):</span>
                            <span class="k">continue</span>

                        <span class="n">inter</span><span class="o">.</span><span class="n">setV2</span><span class="p">(</span><span class="n">delaunay</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">n2</span><span class="p">])</span>

                        <span class="c1"># actual intersection (returns a list of triangles with 3d coordinates)</span>
                        <span class="n">isSet</span> <span class="o">=</span> <span class="n">inter</span><span class="o">.</span><span class="n">intersect</span><span class="p">()</span>
                        <span class="n">vols</span> <span class="o">=</span> <span class="p">[</span><span class="n">misc</span><span class="o">.</span><span class="n">signedVolumeOfTriangle</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">isSet</span><span class="p">]</span>
                        <span class="c1"># get volume of intersection</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vols</span><span class="p">)):</span>
                            <span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">vols</span><span class="p">)</span>
        <span class="c1"># if user wants to keep convex decomposition, create a group with all parts for each object</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keepCD</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">convexHulls</span><span class="p">):</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_vhacd&#39;</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else delete all convex hull objects</span>
            <span class="p">[</span><span class="n">cmds</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">convexHulls</span><span class="p">]</span>
        <span class="c1"># delete convex decomposition structures (original vhacd output)</span>
        <span class="n">cmds</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hullError</span><span class="p">):</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Volume Error: volume of object is bigger than the volume of the convex decomposition! This indicates holes inside vhacd-result. Please check decomposition and adjust parameter for vhacd (e.g. depth)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setResult</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">volumes</span><span class="p">))</span>

<span class="c1"># creator function</span>
<div class="viewcode-block" id="intersectionCreator"><a class="viewcode-back" href="../../pk_src.intersection.html#pk_src.intersection.intersectionCreator">[docs]</a><span class="k">def</span> <span class="nf">intersectionCreator</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">OpenMayaMPx</span><span class="o">.</span><span class="n">asMPxPtr</span><span class="p">(</span> <span class="n">intersection</span><span class="p">()</span> <span class="p">)</span></div>

<span class="c1"># syntax creator function</span>
<div class="viewcode-block" id="intersectionSyntaxCreator"><a class="viewcode-back" href="../../pk_src.intersection.html#pk_src.intersection.intersectionSyntaxCreator">[docs]</a><span class="k">def</span> <span class="nf">intersectionSyntaxCreator</span><span class="p">():</span>
    <span class="n">syntax</span> <span class="o">=</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="p">()</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">setObjectType</span><span class="p">(</span><span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kStringObjects</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;kcd&quot;</span><span class="p">,</span> <span class="s2">&quot;keepConvexDecomposition&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kBoolean</span><span class="p">)</span>
    <span class="c1"># flags for vhacd</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;tmp&quot;</span><span class="p">,</span> <span class="s2">&quot;temporaryDir&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kString</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;exe&quot;</span><span class="p">,</span> <span class="s2">&quot;executable&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kString</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;res&quot;</span><span class="p">,</span> <span class="s2">&quot;resolution&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kLong</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kLong</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;con&quot;</span><span class="p">,</span> <span class="s2">&quot;concavity&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kDouble</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;pd&quot;</span><span class="p">,</span> <span class="s2">&quot;planeDownsampling&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kLong</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;chd&quot;</span><span class="p">,</span> <span class="s2">&quot;convexHullDownsampling&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kLong</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kDouble</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kDouble</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kDouble</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span> <span class="s2">&quot;normalizeMesh&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kBoolean</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kBoolean</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;vtx&quot;</span><span class="p">,</span> <span class="s2">&quot;maxNumVerticesPerCH&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kLong</span><span class="p">)</span>
    <span class="n">syntax</span><span class="o">.</span><span class="n">addFlag</span><span class="p">(</span><span class="s2">&quot;vol&quot;</span><span class="p">,</span> <span class="s2">&quot;minVolumePerCH&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">MSyntax</span><span class="o">.</span><span class="n">kDouble</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">syntax</span></div>

<span class="c1"># create button for shelf</span>
<div class="viewcode-block" id="addButton"><a class="viewcode-back" href="../../pk_src.intersection.html#pk_src.intersection.addButton">[docs]</a><span class="k">def</span> <span class="nf">addButton</span><span class="p">(</span><span class="n">parentShelf</span><span class="p">):</span>
    <span class="k">pass</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Enrico Reich.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>